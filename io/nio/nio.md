
#### ByteBuffer
- 官方解释A byte buffer，一个字节缓冲区。
  
- HeapByteBuffer
    - 在jvm堆上面的一个buffer，底层的本质是一个数组	
    - 由于内容维护在jvm里，所以把内容写进buffer里速度会快些；并且，可以更容易回收
- DirectByteBuffer extends MappedByteBuffer
    - 底层的数据其实是维护在操作系统的内存中，而不是jvm里，DirectByteBuffer里维护了一个引用address指向了数据，从而操作数据	
    - 跟外设（IO设备）打交道时会快很多，因为外设读取jvm堆里的数据时，不是直接读取的，而是把jvm里的数据读到一个内存块里，再在这个块里读取的，如果使用DirectByteBuffer，则可以省去这一步，实现zero copy
    
    
    
    
#### FileChannel
- FileChannel 存在于 java.nio 包中，属于 NIO 的一种，但是注意 NIO 并不一定意味着非阻塞，这里的 FileChannel 就是阻塞的；较为特殊的是后者 MMAP，它是由 FileChannel 调用 map 方法衍生出来的一种特殊读写文件的方式，被称之为内存映射
- MappedByteBuffer 便是 JAVA 中 MMAP 的操作类。
  
- FileChannel 是直接把 ByteBuffer 中的数据写入到磁盘吗
    - ByteBuffer 中的数据和磁盘中的数据还隔了一层，这一层便是 PageCache，是用户内存和磁盘之间的一层缓存
    - 我们可以认为 filechannel.write 写入 PageCache 便是完成了落盘操作，但实际上，操作系统最终帮我们完成了 PageCache 到磁盘的最终写入，理解了这个概念，你就应该能够理解 FileChannel 为什么提供了一个 force() 方法，用于通知操作系统进行及时的刷盘
- FileChannel 为什么比普通 IO 要快
    - FileChannel 采用了 ByteBuffer 这样的内存缓冲区，让我们可以非常精准的控制写盘的大小，这是普通 IO 无法实现的
    - pageCache 
        - ByteBuffer 中的数据和磁盘中的数据还隔了一层，这一层便是 PageCache，是用户内存和磁盘之间的一层缓存
    
    
    
#### mmap Memory Mapped Files(后面简称mmap)也被翻译成内存映射文件
- 内存，我们通常指向计算机中的DRAM，上面可以保存数据。为了访问内存，我们对内存进行编址，所有编址的集合，组成内存空间；
- 内存的空间，从总线上看到的结果，我们一般称为物理地址空间，物理地址空间不但包括内存，也包括IO，物理空间的大小和地址总线的长度相关，可以远远大于DRAM的实际大小
    - CPU发起访问内存的操作，需要经过MMU的地址翻译，这个翻译本质上是一个转换算法pa=f(va) va虚拟地址 pa物理地址
- (虚拟内存)进程看到的所有地址组成的空间，就是虚拟空间。虚拟空间是某个进程对分配给它的所有物理地址（已经分配的和将会分配的）的重新映射
    - 虚拟空间可以很大，但不表示物理内存也需要很大。每个进程有自己的虚拟空间（切换进程的时候切换MMU的翻译表即可），这些虚拟空间可以映射到物理内存的不同或者相同的位置
- mmap的作用，在应用这一层，是让你把文件的某一段，当作内存一样来访问。内核和驱动如何实现的，性能高不高这些问题，这层语义上没有承诺
    - mmap之后，文件的内容在磁盘上是不能被CPU访问的，所以当CPU真的在这个地址上发起读写执行等操作时，OS会进入异常，异常中会调用文件系统把一页或者多页的文件内容加载到物理内存中
    - mmap的工作原理，当你发起这个调用的时候，它只是在你的虚拟空间中分配了一段空间，连真实的物理地址都不会分配的，当你访问这段空间，CPU陷入OS内核执行异常处理，然后异常处理会在这个时间分配物理内存，并用文件的内容填充这片内存，然后才返回你进程的上下文，这时你的程序才会感知到这片内存里有数据
- 内存映射文件，我们之后对内存中 MappedByteBuffer 做的任何操作，都会被最终映射到文件之中，
    - 内存映射文件的作用是使一个磁盘文件与存储空间中的一个缓冲区建立映射关系，然后当从缓冲区中取数据，就相当于读文件中的相应字节；而将数据存入缓冲区，就相当于写文件中的相应字节。这样就可以不使用read和write直接执行I/O了
- mmap
    - mmap 把文件映射到用户空间里的虚拟内存，文件映射至内存(进程空间),省去了从内核缓冲区复制到用户空间的过程，文件中的位置在虚拟内存中有了对应的地址，可以像操作内存一样操作这个文件，相当于已经把整个文件放入内存，但在真正使用到这些数据前却不会消耗物理内存，也不会有读写磁盘的操作

#### 堆外内存
- 可以使用池 + 堆外内存 的组合方式，来对生命周期较短，但涉及到 I/O 操作的对象进行堆外内存的再使用 (Netty 中就使用了该方式)
    - 创建堆外内存的消耗要大于创建堆内内存的消耗，所以当分配了堆外内存之后，尽可能复用它。
- 堆外内存优势在 IO 操作上，对于网络 IO，使用 Socket 发送数据时，能够节省堆内存到堆外内存的数据拷贝
    
- 用户态：只能受限的访问内存，且不允许访问外围设备，占用cpu的能力被剥夺，cpu资源可以被其他程序获取。
- 内核态：cpu可以访问内存的所有数据，包括外围设备，例如硬盘，网卡，cpu也可以将自己从一个程序切换到另一个程序。
    - 由操作系统内核操作，读写磁盘，读写网络都是由这负责
- 系统调用：为了使上层应用能够访问到这些资源，内核为上层应用提供访问的接口

- vs PageCache 
    - HeapByteBuffer -> DirectByteBuffer -> PageCache -> Disk

- [https://www.cnkirito.moe/file-io-best-practise/]
- [https://zhuanlan.zhihu.com/p/308054212]
- [https://www.zhihu.com/org/teng-xun-ji-zhu-gong-cheng/posts]