

### 计算机
- 三大核心部件
    - CPU
        - 中央处理器（CPU，Central Processing Unit）是一块超大规模的集成电路，是一台计算机的运算核心（Core）和控制核心（ Control Unit）
        - 功能主要是解释计算机指令以及处理计算机软件中的数据
        - CPU主要有运算器、控制器、寄存器组合内部总线等部件组成
            - 运算器
                - 累加器
            - 控制器 
                - 控制器一般包括指令控制逻辑、时序控制逻辑、总线控制逻辑和中断控制逻辑等几个部分
            - 寄存器   
                - 寄存器是有限存贮容量的高速存贮部件，它们可用来暂存指令、数据和位址
                - 指令寄存器（IR）
                    - 当CPU执行一条指令时，先把它从内存储器取到缓冲寄存器中，再送入IR暂存
                - 程序计数器（PC）
                    - PC具有寄存信息和计数两种功能，又称为指令计数器。程序的执行分为两种情况，一是顺序执行，而是转移执行。当程序开始执行前，将程序的起始地址送入PC，该地址在程序加载到内容是确定，因此PC的内容即是程序第一条指令的地址。执行指令时CPU自动修改PC的内容，以便使其保持的总是将要执行的下一条指令的地址
        - 4核
            - 多核心技术是将多个一样的 CPU 放置于一个封装内（或直接将两个 CPU 做成一个芯片）
            - 4个处理器核心
        - 单核双线程
            - 英特尔的 HT 技术是在 CPU 内部仅复制必要的资源、让 单核模拟成两个线程；也就是一个实体核心，两个逻辑线程，在一单位时间内处理两个线程的工作
            - 超线程
        - 选用CPU不能只看核心数量，必须综合其它重要参数，比如cpu主频、总线速度、制作工艺，一级、二级、三级缓存
    - 存储器
        - 内存
            - 高速缓冲存储器(Cache)
                - L1、L2、L3
                    - L1/L2 Cache通常都是每个CPU核心一个
                    - L3
                        - 这意味着每增加一个CPU核心都要增加相同大小的面积，即使各个CPU核心的L2 Cache有很多相同的数据也只能各保存一份，因而一个所有核心共享的L3 Cache也就有必要了
                - 高速缓冲存储器是存在于主存与CPU之间的一级存储器， 由静态存储芯片(SRAM)组成，容量比较小但速度比主存高得多， 接近于CPU的速度
                - 当某一硬件要读取数据时，会首先从缓存中查找需要的数据，如果找到了则直接执行，找不到的话则从内存中找。由于缓存的运行速度比内存快得多，故缓存的作用就是帮助硬件更快地运行
            - 主存(Main Memory)
                - RAM
                - ROM
        - 辅存
            - 磁盘
    - 输入/输出（I/O）设备
        

- 计算机的基本硬件系统由运算器、控制器、存储器和输入、输出设备五大部件组成。运算器和控制器等部件被集成在一起统称为中央处理单元
### 多线程并发的意义
- 计算机内部不止CPU一个部件在工作，如A这件事CPU可以分派给其他部件帮它完成，事件处理过程CPU不等待通过多线程处理其他如B事件
- 正因为这样派发任务，通讯，等待的过程，并发系统才彰显出它的意义
### 内存操作
- 如redis

### IO

- 磁盘IO
    - IO所需要的CPU资源非常少。大部分工作是分派给DMA完成的
    - 异步IO
        - CPU计算文件地址 > 委派DMA读取文件 > DMA接管总线 > CPU的A进程阻塞，挂起 > CPU切换到B进程 > DMA读完文件后通知CPU（一个中断异常） > CPU切换回A进程操作文件
        - 假设原先读取文件CPU需要傻等50纳秒。现在尽管两次上下文切换要各消耗5纳秒。CPU还是赚了40纳秒时间片
- 网络IO

### 虚拟内存
- 虚拟内存是操作系统物理内存和进程之间的中间层，它为进程隐藏了物理内存这一概念，为进程提供了更加简洁和易用的接口以及更加复杂的功能
- 现代的操作系统都引入了虚拟内存，进程持有的虚拟地址（Virtual Address）会经过内存管理单元（Memory Mangament Unit）的转换变成物理地址2，然后再通过物理地址访问内存
- 缓存
    - 虚拟内存可以看作是在磁盘上一片空间，当这片空间中的一部分访问比较频繁时，该部分数据会以页为单位被缓存到主存中以加速 CPU 访问数据的性能
        - 虚拟内存利用空间较大的磁盘存储作为"内存"并使用主存储缓存进行加速，让上层认为操作系统的内存很大而且很快，然而区域很大的磁盘并不快，而很快的内存也并不大。
        - 操作系统以页为单位管理内存，当进程发现需要访问的数据不在内存时，操作系统可能会将数据以页的方式加载到内存中，这个过程是由内存管理单元（MMU）完成的
    - 虚拟内存中的虚拟页（Virtual Page，PP）可能处于以下的三种状态 — 未分配（Unallocated）、未缓存（Uncached）和已缓存（Cached），其中未分配的内存页是没有被进程申请使用的，也就是空闲的虚拟内存，不占用虚拟内存磁盘的任何空间，未缓存和已缓存的内存页分别表示仅加载到磁盘中的内存页和已经加载到主存中的内存页
        - 当用户程序访问未被缓存的虚拟页时，硬件就会触发缺页中断（Page Fault，PF），在部分情况下，被访问的页面已经加载到了物理内存中，但是用户程序的页表（Page Table）并不存在该对应关系，这时我们只需要在页表中建立虚拟内存到物理内存的关系；在其他情况下，操作系统需要将磁盘上未被缓存的虚拟页加载到物理内存中
        - 因为主内存的空间是有限的，当主内存中不包含可以使用的空间时，操作系统会从选择合适的物理内存页驱逐回磁盘，为新的内存页让出位置，选择待驱逐页的过程在操作系统中叫做页面替换（Page Replacement）。缺页中断和页面替换技术都是操作系统调页算法（Paging）的一部分，该算法的目的就是充分利用内存资源作为磁盘的缓存以提高程序的运行效率
- 内存管理
    - 虚拟内存可以为正在运行的进程提供独立的内存空间，制造一种每个进程的内存都是独立的假象；在 64 位的操作系统上，每个进程都会拥有 256 TiB 的内存空间，内核空间和用户空间分别占 128 TiB
        - 每个进程的虚拟内存空间是完全独立的，所以它们都可以完整的使用 0x0000000000000000 到 0x00007FFFFFFFFFFF 的全部内存
    - 虚拟内存空间只是操作系统中的逻辑结构，需要为进程实现地址翻译器，实现从虚拟地址到物理地址的转换，页表是虚拟内存系统中的重要数据结构，每一个进程的页表中都存储了从虚拟内存到物理内存页的映射关系
    - 四层页表 五层页表
    - 多个进程可以通过虚拟内存共享物理内存。
        - 如 Redis 快照使用子进程 的写时复制就利用了虚拟内存的这个特性，当在 Linux 中调用 fork 创建子进程时，实际上只复制了父进程的页表，父子进程会通过不同的页表指向相同的物理内存
    - 虚拟内存不仅可以在 fork 时用于共享进程的物理内存，提供写时复制的机制，还能共享一些常见的动态库减少物理内存的占用，所有的进程都可能调用相同的操作系统内核代码
    - 独立的虚拟内存空间也会简化内存的分配过程，当用户程序向操作系统申请堆内存时，操作系统可以分配几个连续的虚拟页，但是这些虚拟页可以对应到物理内存中不连续的页中
- 内存保护
    - 如果每一个进程都持有独立的虚拟内存空间，那么虚拟内存中页表可以理解成进程和物理页的『连接表』，其中可以存储进程和物理页之间的访问关系，包括读权限、写权限和执行权限
    - 内存管理单元可以决定当前进程是否有权限访问目标的物理内存，这样我们就最终将权限管理的功能全部收敛到虚拟内存系统中，减少了可能出现风险的代码路径
    - 操作系统中的用户程序不应该修改只读的代码段，也不应该读取或者修改内核中的代码和数据结构或者访问私有的以及其他的进程的内存，如果无法对用户进程的内存访问进行限制，攻击者就可以访问和修改其他进程的内存影响系统的安全    
- 作用
    - 虚拟内存可以利用内存起到缓存的作用，提高进程访问磁盘的速度
        - 虚拟内存可以结合磁盘和物理内存的优势为进程提供看起来速度足够快并且容量足够大的存储；
    - 虚拟内存可以为进程提供独立的内存空间，简化程序的链接、加载过程并通过动态库共享内存
        - 虚拟内存可以为进程提供独立的内存空间并引入多层的页表结构将虚拟内存翻译成物理内存，进程之间可以共享物理内存减少开销，也能简化程序的链接、装载以及内存分配过程；
    - 虚拟内存可以控制进程对物理内存的访问，隔离不同进程的访问权限，提高系统的安全性
    

### fork
- 在计算机编程领域，尤其是 Unix 和类 Unix 系统中，fork 都是一个进程用于创建自己拷贝的操作，它往往都是被操作系统内核实现的系统调用，也是操作系统在 Unix 系统中创建新进程的主要方法

- 在 fork 函数调用时，父进程和子进程会被 Kernel 分配到不同的虚拟内存空间中，所以在两个进程看来它们访问的是不同的内存
    - 在真正访问虚拟内存空间时，Kernel 会将虚拟内存映射到物理内存上，所以父子进程共享了物理上的内存空间
    - 当父进程或者子进程对共享的内存进行修改时，共享的内存才会以页为单位进行拷贝，父进程会保留原有的物理空间，而子进程会使用拷贝后的新物理空间
        - Redis RDB 
            - 使用 BGSAVE 命令时，Redis 会立刻 fork 出一个子进程，子进程会执行『将内存中的数据以 RDB 格式保存到磁盘中』这一过程，而 Redis 服务在 BGSAVE 工作期间仍然可以处理来自客户端的请求
            - 在 Redis 服务中，子进程只会读取共享内存中的数据，它并不会执行任何写操作，只有父进程会在写入时才会触发这一机制
            - 对于大多数的 Redis 服务或者数据库，写请求往往都是远小于读请求的，所以使用 fork 加上写时拷贝这一机制能够带来非常好的性能，也让 BGSAVE 这一操作的实现变得非常简单

- 调用 fork 后的父子进程会运行在不同的内存空间中，但 fork 发生时两者的内存空间有着完全相同的内容，对内存的写入和修改、文件的映射都是独立的，两个进程不会相互影响，除此之外，子进程几乎是父进程的完整副本（Exact duplicate）
    - The child process and the parent process run in separate memory spaces. At the time of fork() both memory spaces have the same content. Memory writes, file mappings (mmap(2)), and unmappings (munmap(2)) performed by one of the processes do not affect other.
    - 最关键的点在于父子进程的内存在 fork 时是完全相同的，在 fork 之后进行写入和修改也不会相互影响
        - 这其实就完美的解决了redis RDB快照这个场景的问题 —— 只需要某个时间点下内存中的数据，而父进程可以继续对自己的内存进行修改，这既不会被阻塞，也不会影响生成的快照

- 写时拷贝（Copy-on-Write）
    - 既然父进程和子进程拥有完全相同的内存空间并且两者对内存的写入都不会相互影响，那么是否意味着子进程在 fork 时需要对父进程的内存进行全量的拷贝
    - fork 时全量拷贝内存也是难以接受的，假设我们需要在命令行中执行一个命令，我们需要先通过 fork 创建一个新的进程再通过 exec 来执行程序，fork 拷贝的大量内存空间对于子进程来说可能完全没有任何作用的，但是却引入了巨大的额外开销
    - 写时拷贝的主要作用就是将拷贝推迟到写操作真正发生时，这也就避免了大量无意义的拷贝操作
    
#### 内核态 用户态 系统调用
- 内核态：控制计算机的硬件资源，并提供上层应用程序运行的环境。比如socket I/0操作或者文件的读写操作等
- 用户态：上层应用程序的活动空间，应用程序的执行必须依托于内核提供的资源。
- 系统调用：为了使上层应用能够访问到这些资源，内核为上层应用提供访问的接口
- 通过JNI调用的native方法实际上就是从用户态切换到了内核态的一种方式。并且通过该系统调用使用操作系统所提供的功能
- 为什么需要用户进程(位于用户态中)要通过系统调用(Java中即使JNI)来调用内核态中的资源，或者说调用操作系统的服务了
    - intel cpu提供Ring0-Ring3四种级别的运行模式，Ring0级别最高，Ring3最低。Linux使用了Ring3级别运行用户态，Ring0作为内核态。Ring3状态不能访问Ring0的地址空间，包括代码和数据
        - 因此用户态是没有权限去操作内核态的资源的，它只能通过系统调用完成用户态到内核态的切换，然后在完成相关操作后再有内核态切换回用户态。
    - sysctl machdep.cpu
      - machdep.cpu.brand_string: Intel(R) Core(TM) i5-5257U CPU @ 2.70GHz
      
#### mmap
