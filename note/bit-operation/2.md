
/****1****/

>> 右移运算符
规则 a >> b 将数值 a 的二进制数值从 0 位算起到第 b - 1 位，整体向右方向移动 b 位，符号位不变，高位空出来的位补数值 0。

5 >> 1 ===>  1000 0000 0000 0101 >> 1  = 1000 0000 0000 0010 = 2
7 >> 2 ===>  1000 0000 0000 0111 >> 2  = 1000 0000 0000 0001 = 1
9 >> 3 ===>  1000 0000 0000 1001 >> 3  = 1000 0000 0000 0001 = 1
11 >> 2 ===> 1000 0000 0000 1011 >> 2 = 1000 0000 0000 0010 = 2

大家发现什么规律没有？a >> b = a / ( 2 ^ b ) ,所以 5 >> 1= 5 / 2 = 2,11 >> 2 = 11 / 4 = 2。

<< 左移运算符
规则 a << b 将数值 a 的二进制数值从 0 位算起到第 b - 1 位，整体向左方向移动 b 位，符号位不变，低位空出来的位补数值 0。
5 << 1 ===>  1000 0000 0000 0101 << 1  = 1000 0000 0000 1010 = 10
7 << 2 ===>  1000 0000 0000 0111 << 2  = 1000 0000 0001 1100 = 28
9 << 3 ===>  1000 0000 0000 1001 << 3  = 1000 0000 0100 1000 = 72
11 << 2 ===> 1000 0000 0000 1011 << 2 = 1000 0000 0010 1100 = 44

很明显就可以看出 a << b = a * (2 ^ b)

综合上面两个可以看到，如果某个数值右移 n 位，就相当于拿这个数值去除以 2 的 n 次幂。如果某个数值左移 n 位，就相当于这个数值乘以 2 ^ n。
--------------------- 
作者：frank909 
来源：CSDN 
原文：https://blog.csdn.net/briblue/article/details/70296326 
版权声明：本文为博主原创文章，转载请附上博文链接！



/****2****/

1．  在这6种操作符，只有~取反是单目操作符，其它5种都是双目操作符。

2．  位操作只能用于整形数据，对float和double类型进行位操作会被编译器报错。

3．  对于移位操作，在微软的VC6.0和VS2008编译器都是采取算术称位即算术移位操作，算术移位是相对于逻辑移位，它们在左移操作中都一样，低位补0即可，但在右移中逻辑移位的高位补0而算术移位的高位是补符号位。如下面代码会输出-4和3。

	int a = -15, b = 15;
	printf("%d %d\n", a >> 2, b >> 2);
因为15=0000 1111(二进制)，右移二位，最高位由符号位填充将得到0000 0011即3。-15 = 1111 0001(二进制)，右移二位，最高位由符号位填充将得到1111 1100即-4（见注1）。

4．  位操作符的运算优先级比较低，因为尽量使用括号来确保运算顺序，否则很可能会得到莫明其妙的结果。比如要得到像1，3，5，9这些2^i+1的数字。写成int a = 1 << i + 1;是不对的，程序会先执行i + 1，再执行左移操作。应该写成int a = (1 << i) + 1;

5．  另外位操作还有一些复合操作符，如&=、|=、 ^=、<<=、>>=。
--------------------- 
作者：MoreWindows 
来源：CSDN 
原文：https://blog.csdn.net/MoreWindows/article/details/7354571 
版权声明：本文为博主原创文章，转载请附上博文链接！

注1．int类型一般占4字节，32位。因此15准确表达为

15=00000000 00000000 00000000 00001111(二进制)

-15准确表达为

-15=11111111 11111111 11111111 11110001(二进制)

为了简便起见，文章中使用15=00001111(二进制)，-15=11110001(二进制)。
--------------------- 
作者：MoreWindows 
来源：CSDN 
原文：https://blog.csdn.net/MoreWindows/article/details/7354571 
版权声明：本文为博主原创文章，转载请附上博文链接！


/****3****/

二进制位运算---左移(<<)右移(>>)
(1).二进制中负数的计算
负数以正数的补码表示
原码：一个整数按照绝对值的大小转化成二进制的数
反码：将二进制数按位取反
补码：反码加 1
以-14 举例
原码：14 即 00000000  00000000  00000000  00001110
反码：         11111111  11111111  11111111  11110001
补码：          11111111 11111111  11111111  11110010
所以-14  的二进制是 11111111 11111111  11111111  11110010
假设 我们得到  二进制让我们求整数 就是倒着来取相反数
如二进制是           11111111  11111111  11111111  11110010
得到反码减1         11111111  11111111  11111111   11110001
原码：                  00000000  00000000  00000000   00001110
即  1110  = 14  所以取反  就是-14

(2).<<左移运算符
1.将一个运算对象的各二进制位全部左移若干位（左边的二进制丢弃，右边补0）
（注意：java中 整数位 32位）
11 << 2 = 44
-14 <<2 =-56
-14的二进制（11111111  11111111  11111111 11110010）左移2位 为
11111111  11111111  11111111  11001000 结果为（-56）
【补充】：对于左移，直观的理解为，对于正数来说，左移相当于乘以2（但效率比乘法高）；对于负数来说，没有直观的理解。
(3).>>右移运算符
将一个运算对象的各二进制位全部右移若干位，正数左补0，负数左补1.
4 >> 2 = 1;
-14 >> 2 = -4;
【补充】：对于右移，直观的理解为，对于正数来说，右1移相当于除以2（但效率比除法高）；对于负数来说，没有直观的理解。

作者：Ferrari1001
链接：https://www.jianshu.com/p/19ed5ff6a945
来源：简书
简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。

/****4****/
-1 << 29计算过程

负数的二进制以正数的补码表示
原码：一个整数按照绝对值的大小转化成二进制的数
反码：将二进制数按位取反
补码：反码加 1
private static final int RUNNING    = -1 << 29; 
==================================================
0000 0000 0000 0000 0000 0000 0000 0001	(-1原码)

1111 1111 1111 1111 1111 1111 1111 1110 (取反得反码)

1111 1111 1111 1111 1111 1111 1111 1111	(+1得补码)

1110 0000 0000 0000 0000 0000 0000 0000 (左移29位)

1101 1111 1111 1111 1111 1111 1111 1111 (-1得反码)

0010 0000 0000 0000 0000 0000 0000 0000 (取反得原码) RUNNING = - (1的 30-1 次方) = - 536870912

=======
-14 >> 2
0000 0000 0000 0000 0000 0000 0000 1110
1111 1111 1111 1111 1111 1111 1111 0001
1111 1111 1111 1111 1111 1111 1111 0010

1111 1111 1111 1111 1111 1111 1111 1100

1111 1111 1111 1111 1111 1111 1111 1011
0000 0000 0000 0000 0000 0000 0000 0100

-4