#### 分布式事务(全局事务)
- 分布式事务模型
    - 事务参与者/资源管理器 RM
    - 事务协调者/事务管理器 TM 
    - 在分布式事务模型中，一个 TM 管理多个 RM，即一个服务程序访问多个数据源；TM 是一个全局事务管理器，协调多方本地事务的进度，使其共同提交或回滚，最终达成一种全局的 ACID 特性
    
- 二将军问题和幂等性
    - 网络二将军问题，二将军问题是网络领域的一个经典问题
    - 发出的请求没有得到响应。为了确保服务端成功写入数据，客户端只能重发请求，直至接收到服务端的响应
    - 网络二将军问题的存在使得消息的发送者往往要重复发送消息，直到收到接收者的确认才认为发送成功，但这往往又会导致消息的重复发送
        - 因此要保证一次事务中的扣款请求无论被发送多少次，接收方有且只执行一次扣款动作，这种保证机制叫做接收方的幂等性
        - 幂等性
            - 为保证幂等而进行的去重
        
- 两阶段提交（2PC）
    - 2PC 是一种实现分布式事务的简单模型
        - 准备阶段
            - 事务协调者向各个事务参与者发起询问请求
            - 事务参与者各自执行本地事务到待提交阶段并响应
                - Y
                - N
                - 超时
        - 提交阶段
            - 事务协调者收到各个事务参与者回复Y，则向所有事务参与者发起事务提交操作
            - 事务参与者各自执行本地事务提交操作并回复
                - Y
                - N
                - 超时
            - 协调者向所有参与者发起事务回滚操作，然后所有参与者收到后各自执行本地事务回滚操作并向协调者发送 ACK
    - 参与者都要实现三个接口 Prepare、commit、rollback，可以将这三个接口简单地（但不严谨地）理解成 XA 协议
        - XA 协议是 X/Open 提出的分布式事务处理标准。MySQL、Oracle、DB2 这些主流数据库都实现了 XA 协议，因此都能被用于实现 2PC 事务模型。
        - XA ("eXtended Architecture") is an X/Open group standard for accessing several back-end data stores within the same global transaction. The specification governs how an XA transaction manager (such as Atomikos®) can tell a database (like Oracle, MySQL, PostgreSQL) what work is going on as part of what transaction, and how to conduct the two-phase commit (2PC) protocol at the end of each transaction. Also included is how to recover pending transactions from the data store.
    - 存在的问题
        - 同步阻塞问题
            - 准备阶段导致相关资源被排他锁住；在准备阶段，要等待所有的参与者返回，才能进入阶段二，在这期间，各个参与者上面的相关资源被排他地锁住，参与者上面意图使用这些资源的本地事务只能等待。因为存在这种同步阻塞问题，所以影响了各个参与者的本地事务并发度
            - 单点故障(协调者宕机)
                - 准备阶段完成后，如果协调者宕机，所有的参与者都收不到提交或回滚指令，参与者会一直阻塞下去，所有的参与者还都处于锁定事务资源的状态中，而无法继续完成事务操作。（如果是协调者挂掉，可以重新选举一个协调者，但是无法解决因为协调者宕机导致的参与者处于阻塞状态的问题）
        - 数据不一致
            - 发生了局部网络异常或者在发送commit请求过程中协调者发生了故障，部分参与者接到commit请求之后就会执行commit操作
        - 网络二将军问题
            - 提交阶段，协调者向所有的参与者发送了提交指令，如果一个参与者未返回 ACK，那么协调者不知道这个参与者内部发生了什么，也就无法决定下一步是否进行全体参与者的回滚。
    - 适用场景
        - 通常用来解决多个数据库之间的事务问题，比较局限
        - 参与者实现了 XA 协议，例如使用实现了 XA 协议的数据库作为参与者可以完成 2PC 过程
    - 不适用场景
        - 在多个系统服务利用 api 接口相互调用的时候，就不遵守 XA 协议了，这时候 2PC 就不适用了。所以 2PC 在分布式应用场景中很少使用。
- 三阶段提交
    - CanCommit、PreCommit、DoCommit三个阶段
        - 第一阶段
            - 事务协调者询问是否可以执行事务提交操作，正常情况下，如果参与者自身认为可以顺利执行事务，则返回Yes响应
        - 第二阶段
            - 参与者接收到PreCommit请求后，会执行事务操作，并将undo和redo信息记录到事务日志中
            - 事务参与者在等待超时之后，仍未收到协调者的请求，则执行事务的中断
        - 第三阶段，事务参与者无法及时收到事务协调者的提交或回滚请求，事务参与者会在等待超时后继续进行事务的提交
            - 在doCommit阶段，如果参与者无法及时接收到来自协调者的doCommit或者rebort请求时，会在等待超时之后，会继续进行事务的提交。其实这个应该是基于概率来决定的，当进入第三阶段时，说明参与者在第二阶段已经收到了PreCommit请求，那么协调者产生PreCommit请求的前提条件是他在第二阶段开始之前，收到所有参与者的CanCommit响应都是Yes。一旦参与者收到了PreCommit，意味他知道大家其实都同意修改了；所以，一句话概括就是，当进入第三阶段时，由于网络超时等原因，虽然参与者没有收到commit或者abort响应，但是他有理由相信：成功提交的几率很大。
            - 自己的理解
                - 减少了同步阻塞时间
                - 相对于两阶段提交，由于三阶段提交的一阶段CanCommit的存在，减少了数据不一致的概率
    - 与两阶段提交不同的是，三阶段提交有两个改动点
        - 引入超时机制。同时在协调者和参与者中都引入超时机制。
        - 把2PC的准备阶段再次一分为二，保证了在最后提交阶段之前各参与节点的状态是一致的。
    - 解决的问题
        - 利用超时机制解决了 2PC 的同步阻塞问题，避免资源被永久锁定，进一步加强了整个事务过程的可靠性
    - 依然存在的问题
        - 无法应对类似的宕机问题，只不过出现多数据源中数据不一致问题的概率更小
- TCC
    - Try、Confirm、Cancel
    - 在多个系统服务利用 api 接口相互调用，解决多个微服务之间的分布式事务问题。
    - 其本质是一个应用层面上的 2PC，同样分为两个阶段
        - 阶段一：准备阶段 协调者调用每个微服务的try接口将整个全局事务涉及到的资源锁定住，若锁定成功 try 接口向协调者返回 yes
        - 阶段二：提交阶段
            - 所有的服务的 try 接口在阶段一都返回 yes，则进入提交阶段，协调者调用所有服务的 confirm 接口，各个服务进行事务提交
            - 如果有任何一个服务的 try 接口在阶段一返回 no 或者超时，则协调者调用所有服务的 cancel 接口
    - 如何解决 2PC 无法应对宕机问题的缺陷 ？
        - 如何应对事务协调者宕机 ？ * 
        - 不断重试(事务参与者宕机)
            - 无论是 confirm 阶段失败还是 cancel 阶段失败都能通过不断重试直至 confirm 或 cancel 成功
            - 所谓成功就是所有的服务都对 confirm 或者 cancel 返回了 ACK
        - 保证confirm 和 cancel 操作具有幂等性 
            - 在不断重试 confirm 和 cancel 的过程中（考虑到网络二将军问题的存在）有可能重复进行了 confirm 或 cancel，因此还要再保证 confirm 和 cancel 操作具有幂等性
            - 如每个参与者可以维护一个去重表（可以利用数据库表实现也可以使用内存型 KV 组件实现），记录每个全局事务（以全局事务标记 XID 区分）是否进行过 confirm 或 cancel 操作
    - TCC优化       
- 事务状态表方案(借助第三方存储)
    - 一种类似 TCC 的事务解决方案，借助事务状态表来实现
        - 分布式事务ID、事务内容、事务状态
    - 后台任务扫描事务状态判断事务未完成则进行重试
        - 由于重试，每个服务的接口要根据全局的分布式事务 ID 做幂等，原理同TCC的幂等性实现
        
- 基于消息中间件的最终一致性事务方案
    - XA 协议思想
        - 2PC & 3PC 还是 TCC、事务状态表
        - 无论是 2PC & 3PC 还是 TCC、事务状态表，基本都遵守 XA 协议的思想，即这些方案本质上都是事务协调者协调各个事务参与者的本地事务的进度，使所有本地事务共同提交或回滚，最终达成一种全局的 ACID 特性
            - 在协调的过程中，协调者需要收集各个本地事务的当前状态，并根据这些状态发出下一阶段的操作指令
        - 并发度不会太高
            - 操作繁琐、时间跨度大，或者在全局事务期间会排他地锁住相关资源
            - 不适合高并发场景对事务吞吐量的要求
    - 与 XA 协议背道而驰的分布式事务解决方案
        - 利用消息中间件实现的最终一致性全局事务
        
    - 利用消息中间件实现的最终一致性全局事务     
        - 高并发场景实现数据最终一致性 
            - 利用 MQ 实现微服务之间的异步调用、解耦合和流量削峰，支持全局事务的高并发，并保证分布式数据记录的最终一致性
        - 可能的实现缺陷
            - 未考虑网络二将军问题导致的数据不一致
            - 未考虑因为网络延迟产生数据库长事务，影响数据库本地事务的并发度。
            - 重复消费未做幂等性处理，需要去重特性来避免消息重复消费
                - MQ server向消息生产者响应ACK失败(网络二将军问题)导致重复生产消息，导致重复消费
                - MQ server未收到消费者响应的ACK重新推送了该消息导致的重复消费消息
                - 解决
                    - 消费者端维护了一张判重表，这张表中记录了被成功处理的消息，每次接收到新的消息都先判断消息是否被成功处理过，若是的话不再重复处理
            - 保证消息在发送方不丢失，消息在接收方不被重复消费，联合起来就是消息不漏不重，严格实现数据的最终一致性
        - MQ server 的 Confirm 机制 *    
            - MQ server 在 Confirm 机制的驱动下会继续向 repo-service 推送该消息，直到整个事务成功提交
            
- Seata 
    - Seata in AT mode


- CAP & BASE
    - CAP
        - 实际上，不是为了P（分区容错性），必须在C（一致性）和A（可用性）之间任选其一。分区的情况很少出现，CAP在大多时间能够同时满足C和A。
        - 对于分区存在或者探知其影响的情况下，需要提供一种预备策略做出处理：
            - 探知分区的发生；
            - 进入显示的分区模式，限制某些操作；
            - 启动恢复过程，恢复数据一致性，补偿分区发生期间的错误
        - 
    - BASE
        - BASE理论是Basically Available(基本可用)，Soft State（软状态）和Eventually Consistent（最终一致性）三个短语的缩写；核心思想，既是无法做到强一致性（Strong consistency），但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性（Eventual consistency）
            - BA
                - 响应时间上的损失
                - 功能上的损失，降级处理
            - S
                - 什么是软状态呢？相对于原子性而言，要求多个节点的数据副本都是一致的，这是一种“硬状态”
                - 允许系统中的数据存在中间状态，并认为该状态不影响系统的整体可用性，即允许系统在多个不同节点的数据副本存在数据延时
            - E
                - 上面说软状态，然后不可能一直是软状态，必须有个时间期限。在期限过后，应当保证所有副本保持数据一致性，从而达到数据的最终一致性。这个时间期限取决于网络延时、系统负载、数据复制方案设计等等因素
                - 实际工程实践中，最终一致性分为5种
                    - 因果一致性指的是：如果节点A在更新完某个数据后通知了节点B，那么节点B之后对该数据的访问和修改都是基于A更新后的值。于此同时，和节点A无因果关系的节点C的数据访问则没有这样的限制
                    - 读己之所写指的是：节点A更新一个数据后，它自身总是能访问到自身更新过的最新值，而不会看到旧值。其实也算一种因果一致性
                    - 会话一致性将对系统数据的访问过程框定在了一个会话当中：系统能保证在同一个有效的会话中实现 “读己之所写” 的一致性，也就是说，执行更新操作之后，客户端能够在同一个会话中始终读取到该数据项的最新值
                    - 单调读一致性指的是：如果一个节点从系统中读取出一个数据项的某个值后，那么系统对于该节点后续的任何数据访问都不应该返回更旧的值
                    - 单调写一致性指的是：一个系统要能够保证来自同一个节点的写操作被顺序的执行。
                - 在实际的实践中，这5种系统往往会结合使用，以构建一个具有最终一致性的分布式系统。
                - 实际上，不只是分布式系统使用最终一致性，关系型数据库在某个功能上，也是使用最终一致性的。比如备份，数据库的复制过程是需要时间的，这个复制过程中，业务读取到的值就是旧的。当然，最终还是达成了数据一致性。这也算是一个最终一致性的经典案例              
        - BASE是对CAP中一致性和可用性权衡的结果，其来源于对大规模互联网分布式系统实践的总结，是基于CAP定律逐步演化而来。其核心思想是即使无法做到强一致性，但每个应用都可以根据自身业务特点，才用适当的方式来使系统打到最终一致性
    - 总体来说BASE理论面向的是大型高可用、可扩展的分布式系统。与传统ACID特性相反，不同于ACID的强一致性模型，BASE提出通过牺牲强一致性来获得可用性，并允许数据段时间内的不一致，但是最终达到一致状态。同时，在实际分布式场景中，不同业务对数据的一致性要求不一样。因此在设计中，ACID和BASE理论往往又会结合使用
#### 总结

#### 柔性事务的定义与分类
- 刚性事务（如单数据库）完全遵循 ACID 规范，即数据库事务正确执行的四个基本要素
- 柔性事务（如分布式事务）为了满足可用性、性能与降级服务的需要，降低一致性（Consistency）与隔离性（Isolation）的要求，遵循 BASE 理论
同样的，柔性事务也部分遵循 ACID 规范：
原子性：严格遵循
一致性：事务完成后的一致性严格遵循；事务中的一致性可适当放宽
隔离性：并行事务间不可影响；事务中间结果可见性允许安全放宽
持久性：严格遵循

- 柔性事务的分类
- 柔性事务分为：两阶段型、补偿型、异步确保型、最大努力通知型。
      
两阶段型
分布式事务二阶段提交，对应技术上的 XA、JTA/JTS，这是分布式环境下事务处理的典型模式。
补偿型
TCC 型事务（Try-Confirm-Cancel）可以归为补偿型。在 Try 成功的情况下，如果事务要回滚，Cancel 将作为一个补偿机制，回滚 Try 操作；TCC 各操作事务本地化，且尽早提交（没有两阶段约束）；当全局事务要求回滚时，通过另一个本地事务实现“补偿”行为。
TCC 是将资源层的二阶段提交协议转换到业务层，成为业务模型中的一部分。
异步确保型
将一些有同步冲突的事务操作变为异步操作，避免对数据库事务的争用，如消息事务机制。
最大努力通知型
通过通知服务器（消息通知）进行，允许失败，有补充机制  