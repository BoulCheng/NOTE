#### 分布式事务(全局事务)
- 分布式事务模型
    - 事务参与者/资源管理器 RM
    - 事务协调者/事务管理器 TM 
    - 在分布式事务模型中，一个 TM 管理多个 RM，即一个服务程序访问多个数据源；TM 是一个全局事务管理器，协调多方本地事务的进度，使其共同提交或回滚，最终达成一种全局的 ACID 特性
    
- 二将军问题和幂等性
    - 网络二将军问题，二将军问题是网络领域的一个经典问题
    - 发出的请求没有得到响应。为了确保服务端成功写入数据，客户端只能重发请求，直至接收到服务端的响应
    - 网络二将军问题的存在使得消息的发送者往往要重复发送消息，直到收到接收者的确认才认为发送成功，但这往往又会导致消息的重复发送
        - 因此要保证一次事务中的扣款请求无论被发送多少次，接收方有且只执行一次扣款动作，这种保证机制叫做接收方的幂等性
        
- 两阶段提交（2PC）
    - 2PC 是一种实现分布式事务的简单模型
        - 准备阶段
            - 事务协调者向各个事务参与者发起询问请求
            - 事务参与者各自执行本地事务到待提交阶段并响应
                - Y
                - N
                - 超时
        - 提交阶段
            - 事务协调者收到各个事务参与者回复Y，则向所有事务参与者发起事务提交操作
            - 事务参与者各自执行本地事务提交操作并回复
                - Y
                - N
                - 超时
            - 协调者向所有参与者发起事务回滚操作，然后所有参与者收到后各自执行本地事务回滚操作并向协调者发送 ACK
    - 参与者都要实现三个接口 Prepare、commit、rollback，可以将这三个接口简单地（但不严谨地）理解成 XA 协议
        - XA 协议是 X/Open 提出的分布式事务处理标准。MySQL、Oracle、DB2 这些主流数据库都实现了 XA 协议，因此都能被用于实现 2PC 事务模型。
    - 存在的问题
        - 同步阻塞问题
            - 准备阶段导致相关资源被排他锁住；在准备阶段，要等待所有的参与者返回，才能进入阶段二，在这期间，各个参与者上面的相关资源被排他地锁住，参与者上面意图使用这些资源的本地事务只能等待。因为存在这种同步阻塞问题，所以影响了各个参与者的本地事务并发度
            - 单点故障(协调者宕机)
                - 准备阶段完成后，如果协调者宕机，所有的参与者都收不到提交或回滚指令，参与者会一直阻塞下去，所有的参与者还都处于锁定事务资源的状态中，而无法继续完成事务操作。（如果是协调者挂掉，可以重新选举一个协调者，但是无法解决因为协调者宕机导致的参与者处于阻塞状态的问题）
        - 数据不一致
            - 发生了局部网络异常或者在发送commit请求过程中协调者发生了故障，部分参与者接到commit请求之后就会执行commit操作
        - 网络二将军问题
            - 提交阶段，协调者向所有的参与者发送了提交指令，如果一个参与者未返回 ACK，那么协调者不知道这个参与者内部发生了什么，也就无法决定下一步是否进行全体参与者的回滚。
    - 适用场景
        - 通常用来解决多个数据库之间的事务问题，比较局限
        - 参与者实现了 XA 协议，例如使用实现了 XA 协议的数据库作为参与者可以完成 2PC 过程
    - 不适用场景
        - 在多个系统服务利用 api 接口相互调用的时候，就不遵守 XA 协议了，这时候 2PC 就不适用了。所以 2PC 在分布式应用场景中很少使用。
- 三阶段提交
    - 在第三阶段，事务参与者无法及时收到事务协调者的提交或回滚请求，事务参与者会在等待超时后继续进行事务的提交
        - 自己的理解
            - 减少了同步阻塞时间
            - 相对于两阶段提交，由于三阶段提交的一阶段CanCommit的存在，减少了数据不一致的概率
    - 与两阶段提交不同的是，三阶段提交有两个改动点
        - 引入超时机制。同时在协调者和参与者中都引入超时机制。
        - 把2PC的准备阶段再次一分为二，保证了在最后提交阶段之前各参与节点的状态是一致的。
    - 解决的问题
        - 利用超时机制解决了 2PC 的同步阻塞问题，避免资源被永久锁定，进一步加强了整个事务过程的可靠性
    - 依然存在的问题
        - 无法应对类似的宕机问题，只不过出现多数据源中数据不一致问题的概率更小
- TCC
    - Try、Confirm、Cancel
    - 在多个系统服务利用 api 接口相互调用，解决多个微服务之间的分布式事务问题。
    - 其本质是一个应用层面上的 2PC，同样分为两个阶段
        - 阶段一：准备阶段 协调者调用每个微服务的try接口将整个全局事务涉及到的资源锁定住，若锁定成功 try 接口向协调者返回 yes
        - 阶段二：提交阶段
            - 所有的服务的 try 接口在阶段一都返回 yes，则进入提交阶段，协调者调用所有服务的 confirm 接口，各个服务进行事务提交
            - 如果有任何一个服务的 try 接口在阶段一返回 no 或者超时，则协调者调用所有服务的 cancel 接口
    - 如何解决 2PC 无法应对宕机问题的缺陷 ？
        - 如何应对事务协调者宕机 ？ * 
        - 不断重试(事务参与者宕机)
            - 无论是 confirm 阶段失败还是 cancel 阶段失败都能通过不断重试直至 confirm 或 cancel 成功
            - 所谓成功就是所有的服务都对 confirm 或者 cancel 返回了 ACK
        - 保证confirm 和 cancel 操作具有幂等性 
            - 在不断重试 confirm 和 cancel 的过程中（考虑到网络二将军问题的存在）有可能重复进行了 confirm 或 cancel，因此还要再保证 confirm 和 cancel 操作具有幂等性
            - 如每个参与者可以维护一个去重表（可以利用数据库表实现也可以使用内存型 KV 组件实现），记录每个全局事务（以全局事务标记 XID 区分）是否进行过 confirm 或 cancel 操作
            
- 事务状态表方案(借助第三方存储)
    - 一种类似 TCC 的事务解决方案，借助事务状态表来实现
        - 分布式事务ID、事务内容、事务状态
    - 后台任务扫描事务状态判断事务未完成则进行重试
        - 由于重试，每个服务的接口要根据全局的分布式事务 ID 做幂等，原理同TCC的幂等性实现
        
- 基于消息中间件的最终一致性事务方案
    - XA 协议思想
        - 2PC & 3PC 还是 TCC、事务状态表
        - 无论是 2PC & 3PC 还是 TCC、事务状态表，基本都遵守 XA 协议的思想，即这些方案本质上都是事务协调者协调各个事务参与者的本地事务的进度，使所有本地事务共同提交或回滚，最终达成一种全局的 ACID 特性
            - 在协调的过程中，协调者需要收集各个本地事务的当前状态，并根据这些状态发出下一阶段的操作指令
        - 并发度不会太高
            - 操作繁琐、时间跨度大，或者在全局事务期间会排他地锁住相关资源
            - 不适合高并发场景对事务吞吐量的要求
    - 与 XA 协议背道而驰的分布式事务解决方案
        - 利用消息中间件实现的最终一致性全局事务
        
    - 利用消息中间件实现的最终一致性全局事务     
        - 高并发场景实现数据最终一致性 
            - 利用 MQ 实现微服务之间的异步调用、解耦合和流量削峰，支持全局事务的高并发，并保证分布式数据记录的最终一致性
        - 可能的实现缺陷
            - 未考虑网络二将军问题导致的数据不一致
            - 未考虑因为网络延迟产生数据库长事务，影响数据库本地事务的并发度。
            - 重复消费未做幂等性处理，需要去重特性来避免消息重复消费
                - MQ server向消息生产者响应ACK失败(网络二将军问题)导致重复生产消息，导致重复消费
                - MQ server未收到消费者响应的ACK重新推送了该消息导致的重复消费消息
                - 解决
                    - 消费者端维护了一张判重表，这张表中记录了被成功处理的消息，每次接收到新的消息都先判断消息是否被成功处理过，若是的话不再重复处理
            - 保证消息在发送方不丢失，消息在接收方不被重复消费，联合起来就是消息不漏不重，严格实现数据的最终一致性
        - MQ server 的 Confirm 机制 *    
            - MQ server 在 Confirm 机制的驱动下会继续向 repo-service 推送该消息，直到整个事务成功提交
            
- Seata 
    - Seata in AT mode


#### 总结