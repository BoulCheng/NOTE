

#### 渐进时间复杂度
- 对于一个算法，假设其问题的输入大小为n，那么我们可以用 O(n) 来表示其算法时间复杂度(time complexity)。那么，渐进时间复杂度（asymptotic time complexity）就是当n趋于无穷大的时候，O（n）得到的极限值。

- 插入排序常数比快速排序 归并排序常数小，当数据量小时可考虑使用插入排序


#### 线性结构
- 数据排成一排
```
1．集合中必存在唯一的一个"第一个元素"；
2．集合中必存在唯一的一个"最后的元素"；
3．除最后元素之外，其它数据元素均有唯一的"后继"；
4．除第一元素之外，其它数据元素均有唯一的"前驱"。
数据结构中线性结构指的是数据元素之间存在着“一对一”的线性关系的数据结构。
如（a0,a1,a2,.....,an）,a0为第一个元素，an为最后一个元素，此集合即为一个线性结构的集合。
相对应于线性结构，非线性结构的逻辑特征是一个结点元素可能对应多个直接前驱和多个后继。
```

#### 数组
- 线性结构
- 最大优势：支持随机访问(根据索引)
- 通过索引拿到索引对应的元素
- 数组所开辟的空间在内存里是连续分布的,所以可以直接寻找这个索引对应的偏移，直接计算出相应这个数据的存储地址， 

#### 栈
- 线性结构
- 栈有多种实现，如数组实现栈
- 栈对应的操作是数组的操作的子集 
- 只能从一端添加元素，也只能从一端取出元素
- 这一端称为栈顶
- 后进先出 LIFO
- ArrayDeque

#### 队列
- 线性结构
- 队列对应的操作是数组的操作的子集
- 只能从一端(队尾)添加元素，只能从另一端(队首)取出元素
- 先进先出 FIFO 
- 数组实现的循环队列、数组实现的不循环的队列
- 链表实现的队列

#### 链表
- 链表是真正意义上的动态数据结构，不需要处理扩容问题
- 丧失了随机访问的能力

- 栈和队列底层依托数组，通过扩容解决固定容量难题
- 栈和队列也可以通过链表实现
- 数据存储在一种单独的结构中：节点 
- 虚拟头结点：统一对头结点和其他结点的操作，到达简化逻辑的目的
- 分类：有无虚拟头结点 是否双向 是否有尾结点 是否循环
- 数组实现链表：链表结点确定的情况下

#### 递归
- 本质上 将原来的问题转化为更小的同一问题 直到变成最基本的问题 
    - 求解最基本问题
    - 将原问题转化为更小的问题
    
    - 递归调用和子函数调用没有区别，本质是函数调用 
- 递归调用的代价：函数调用+系统栈空间
- 线性结构使用循环就可以解决
- 近乎和链表相关的所有操作，都可以使用递归的形式完成
- leetCode - 203

#### 二分搜索树
- 树结构：高效，将数据使用树结构存储后变得高效
- 树结构本身是一种天然的组织结构
- 平衡二叉树：AVL、红黑树
- 具有顺序性

- 二叉树
    - 和链表一样，具有天然递归结构：每个结点的左右孩子也是一棵二叉树的根结点, 左右子树
    - 和链表一样也是动态数据结构(在创建数据结构时就决定可以容纳多少数据)
    - 数据存储在结点中，每个结点有指向左右孩子的两个变量
    - 具有唯一根结点
    - 每个结点最多有两个孩子，一个孩子都没有的称为 叶子结点
    - 每个结点最多有一个父亲结点 根结点没有父亲结点
    - 满二叉树：除了叶子结点外都有两个孩子 
    - 二叉树不一定是"满"的
    - 一个结点或者空也是二叉树(类似链表)
- 二分搜索树
    - 是二叉树
    - 每个结点的值大于其左子树的每一个结点的值，小于其右子树的每一个结点的值 (每一棵子树也是二分搜索树)
     
    - 存储数据的局限性： 存储的元素必须具有可比较性
    - 若二分搜索树包含重复元素，只需定义：大于等于 或 小于等于
    - 在最坏的情况下退化为链表
    
- 遍历 
    - 前序遍历：访问结点在访问其左右子树前面 非递归实现可以借助栈
    - 中序遍历：访问结点在访问其左子树和右子树的中间； 遍历的结果是所有元素排序后的结果
    - 后序遍历：访问结点在访问其左右子树后面
    
    - 深度优先遍历： 先来到最深的地方
    - 广度优先遍历(层序遍历)： 层序遍历，一层一层遍历， 每个结点都有一个深度的值(根结点为0) 借助队列; 较深度优先遍历可以更快地找到要查找的元素
    
- 后继： 某结点的后继为其右子树最小结点 即比该结点大的最小结点
- 前驱： 某结点的前驱为其左子树最大结点 即比该结点小的最大结点
- 删除二分搜索树的结点，如果要删除的结点既有左子树又有右子树，那么需要找到待删除结点的前驱或后继替代该删除结点
- 深度：根结点深度可以标志为0
- 树的高度：最大的那个深度 
- 结点高度：该结点到叶结点最长简单路径上边的数目 树的高度可以用根的高度来衡量
- 从根节点到叶子节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度包含的节点数为为树的深度，即二叉树节点的层数
- 二叉树的宽度定义为具有最多结点数的层中包含的结点数


- 时间复杂度
    - 复杂度计算 涉及等比数列的求和公式 (如高度为h的满二叉树的总共的节点数)
    - 在O的定义下对数的底的大小通常忽略不计
    - 需要有一个概念：logn这个复杂度是一个非常非常快的一个时间复杂度。 很多高级的排序算法是 nlogn 这个复杂度，比n2 复杂度快了非常多倍；类比logn 和 n 的比较，两边同时乘以n.
    - 时间复杂度是 O(h) h为高度，因为增查删经历的结点数是数的高度，满二叉树的时间复杂度是 O(logn)， 二叉树的平均时间复杂度是 O(logn), 当二分搜索树退化为链表时 将到达最差的时间复杂度O(n) 即链表的时间复杂度。
    - 二叉搜索树致命的问题是最坏的情况退化为链表，即高度等于节点树(按顺序创建二分搜索树)(因为同样的数据可以对应不同的二分搜索树)，解决这个问题的方式就是创建平衡二叉树


#### 集合和映射(高级数据结构 可以通过多种不同的底层数据结构实现)
- 集合 Set：没有重复元素，无重复元素的二分搜索树是非常好的实现"集合"的底层数据结构
    - 无重复元素的二分搜索树实现 
        - 增查删 O(h) h为树的高度
    - 链表实现
        - 增查删 O(n)
- 映射(字典(单词 --> 释意)) Map(dict) : 
```
1 红黑树
牺牲严格的高度平衡，减少旋转次数，以提高性能
2 B树
节点孩子可以有多个 比红黑树高度更小 减少了检查的结点数 减少磁盘访问
3 B+树
B+跟B树不同B+树的非叶子节点不保存关键字记录的指针，只进行数据索引，这样使得B+树每个非叶子节点所能保存的关键字大大增加

B+树的层级更少：相较于B树B+每个非叶子节点存储的关键字数更多，树的层级更少所以查询数据更快

B+树查询速度更稳定：B+所有关键字数据地址都存在叶子节点上，所以每次查找的次数都相同所以查询速度要比B树更稳定;
```