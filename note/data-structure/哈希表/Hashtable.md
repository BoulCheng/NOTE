
### 哈希表
- 相比二叉搜索树，哈希表有一对一对应的映射关系
- 本质是把真正需要关注的内容转化成一个数组的索引(通过哈希函数转化)，然后用一个数组存储相应的内容。增改查都是O(1)的时间复杂度
- 哈希函数：把"键" "索引"
    - "键"通过哈希函数得到的"索引"分布越均匀越好
    - 把任意长度的输入通过散列算法变换成固定长度的输出
- 哈希冲突：两个不同的键通过哈希函数转化之后对应同一个索引
- 关键点
    -  哈希函数的设计
    -  如何解决哈希冲突
- 哈希表充分体现了算法设计领域的经典思想：空间换时间


- 哈希函数的设计 
    - 可以将所有类型的数据相应的哈希函数的设计都以转化成是对于整型进行哈希函数的过程
    - 整数   
        - 小范围正整数 直接作为索引
        - 小范围负整数 进行偏移 变为正整数
        - 大整数 模一个素数 (https://planetmath.org/goodhashtableprimes) 
    - 浮点数
        - 浮点数存储的空间当作整型处理，通过整数的方式来解析
    - 字符串
        - 转化为整型处理
    - 复合类型
        - 转化为字符串处理
        
        
- JAVA hashCode() 
    - Object默认hashCode() 根据对象的地址映射成一个整型
    - 在使用HashSet HashMap时，hashCode()用于计算哈希函数的值，但在产生哈希冲突时，仍然是需要比较两个对象是否是相等的，
        - 也就是两个对象的哈希函数的相等的，当需要判断两个对象是不是真正是相等的，需要使用equals()判断，
        - equal objects must have equal hash codes. 相等的对象必须相等的hashcode，所以覆盖需要使用equals()方法同时需要覆盖hashcode()方法
        - If two objects are equal according to the {@code equals(Object)} method, then calling the {@code hashCode} method on each of the two objects must produce the same integer result.
    - 只是将一个数据类型和一个整型(可正可负 )对应起来，至于这个整型如何和数组中的索引对应，这个由哈希表内部的逻辑完成
    - 整型溢出：对于整型而言，如果已经是最大的整型值了，如果再加1，其实就相当于循环回来变成最小的负的整型值，计算机二进制表示整型的一个特性 

- 哈希冲突的解决
    - 链地址法(separate chaining) 
        - 本质就是一个数组，数组每个位置对应一个查找表(链表、平衡树)，数组动态扩容缩容触发条件是平均每个地址承载元素的到达某个阀值，即平均产生哈希冲突的元素。
        - 闭散列（用此种方法实现的哈希表称之为哈希桶）
        - 每个空间(桶)都是一个查找表
        - 其实整个哈希表就是一个查找表(链表、平衡树)数组
        
        - 链地址法是封闭地址： (数组位置)地址具有排他性，只能包含哈希值等于这个索引的那些元素
    - 开放地址法(与链地址法相反) O(1)
        - 开放地址法：哈希表的每一个地址所有哈希值的元素都有机会进来，每一个地址对所有元素都是开放的， 这就是开放的意思
        - 每个地址不再是存一个查找表，每个地址就是直接存元素，当产生哈希冲突时，元素存放的位置从产生哈希冲突的索引位置向后找，直到找到一个没有存放元素的空位置
        - 具体有
            - 线性探测法： 遇到哈希冲突不停 +1 直到找到空位置
                - ThreadLocal
            - 平方探测： +1 +4 +9 +16 .... 步长的序列是一个平方序列 
            - 二次哈希：使用另外一个哈希函数
        - 扩容：当哈希表中的元素占哈希表整个地址数量的百分比(负载率) 就进行扩容
    - 再哈希法：使用另外一个哈希函数
    
- 安全问题
    - 哈希碰撞攻击
    
- 时间复杂度
    - 均摊复杂度为O(1)

- 缺点
    - 相对于平衡树 失去了 顺序性