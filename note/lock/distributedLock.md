

#### redis

- random_value	一个随机字符串，不同客户端设置的值不能相同。
t1时刻，App1设置了分布式锁resource_1，过期时间为3秒。
App1由于程序慢等原因等待超过了3秒，而resource_1已经在t2时刻被释放。
t3时刻，App2获得这个分布式锁。
App1从等待中恢复，在t4时刻运行DEL resource_1将App2持有的分布式锁释放了。

- 续租 当客户端发现在锁的租期内无法完成操作时，就需要延长锁的持有时间，进行续租（renew）。同解锁一样，客户端应该只能续租自己持有的锁。在Redis中可使用如下Lua脚本来实现续租：

- 一致性
    - Redis的主从同步（replication）是异步进行的，如果向master发送请求修改了数据后master突然出现异常，发生高可用切换，缓冲区的数据可能无法同步到新的master（原replica）上，导致数据不一致。如果丢失的数据跟分布式锁有关，则会导致锁的机制出现问题
    - 三种保障一致性的方法
        - 使用红锁（RedLock）红锁是Redis作者提出的一致性解决方案。红锁的本质是一个概率问题：如果一个主从架构的Redis在高可用切换期间丢失锁的概率是k%，那么相互独立的N个Redis同时丢失锁的概率是多少？如果用红锁来实现分布式锁，那么丢锁的概率是(k%)^N。鉴于Redis极高的稳定性，此时的概率已经完全能满足产品的需求。
          说明: 红锁的实现并非这样严格，一般保证M(1<M=<N)个同时锁上即可，但通常仍旧可以满足需求
        - 使用WAIT命令。 Redis的WAIT命令会阻塞当前客户端，直到这条命令之前的所有写入命令都成功从master同步到指定数量的replica，命令中可以设置单位为毫秒的等待超时时间。
            WAIT只会阻塞发送它的客户端，不影响其它客户端。
            WAIT返回正确的值表示设置的锁成功同步到了replica，但如果在正常返回前发生高可用切换，数据还是可能丢失，此时WAIT只能用来提示同步可能失败，无法保证数据不丢失。您可以在WAIT返回异常值后重新加锁或者进行数据校验。