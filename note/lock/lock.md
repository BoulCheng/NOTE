#锁

- 悲观锁
    - 悲观的假设更新的同时一定会有其他线程同时更新，即假设每次去更新的时候数据都会被修改(即更新非常频繁)
    - 更新时加锁，加锁期间其他线程无法访问资源，只有当更新操作完成后并释放资源锁定后其他线程才可以访问
    - 写多场景，写时虽然需要获取锁，但无需自旋重试
    - synchronized
    - 缺点
        - 当资源被锁定时间比较长时，仅仅是读访问也可能等待比较长时间
- 乐观锁
    - 乐观的假设更新的同时不会有其他线程同时更新，即假设去更新的时刻数据不会被修改(即更新不频繁的场景)
    - 更新时无锁，其他线程依然可以同时正常读访问，但写访问会失败然后重试
    - 通过版本号机制和CAS无锁算法实现，CAS保证原子性 (具体如何保证原子性)
    - 读多场景, 更新时无锁，多线程同时读访问提高并发，即冲突真的很少发生的时候
    - java.util.concurrent.atomic
    - 缺点
        - ABA的问题，就是说：假如一个值原来是A，变成了B，又变成了A，那么CAS检查时会发现它的值没有发生变化，但是实际上却变化了
            - 预期执行一次，但实际因为其他不可控因素导致执行了多次可能会产生错误结果，如用户金额变化操作A： 100 -> 50 ; 操作B: 50 -> 100 ; 但操作A因不可控因素执在操作B前后都执行了一次就会导致错误
            - AtomicStampedReference AtomicMarkableReference 解决
        - 自旋时间长开销大
            - 限制自旋次数，防止进入死循环
        - 只能保证一个共享变量的原子操作
            - 多个共享变量进行操作，可以使用加锁方式(悲观锁)保证原子性
            - 多个共享变量合并成一个共享变量进行CAS操作

