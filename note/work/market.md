#### 分布式数据一致性
- 分布式锁

#### 高并发
- redis lua 脚本

#### 缓存 
- 先处理redis数据 再处理数据库数据 
- 

#### 难点

- 历史K线缓存数据类型的选择 zset
- 更新K线分布式并发安全问题 分布式锁
- 业务复杂问题K线 连续性问题 
- 
- 高并发问题 
    - 高频访问的最新K线放在redis 当下一刻度的K线生成时转存上一K线
    - 数据库索引
    - redis lua

#### 总结
- 最新K线放在redis 数据类型 string（字符串）；历史K线也放在redis 数据类型为zset(sorted set：有序集合) 同时也存放mysql数据库，并且redis中的历史数仅据保存一定的量，会有定时任务定时清理超出的数据量；
- 通过redis lua 保证CAS更新redis最新K线 (比较于reids分布式，虽然可以不使用redis lua，但会增加三次redis访问，也增加释放锁失败的风险，以及等待时不断的访问redis消耗资源等等) 
- 下一刻度K线时间点到达时，定时任务会触发执行生成一条默认值的最新K线，并把上一刻度时间点的最新K线转存到数据库和redis中历史K线，
- 通过redis实现分布式锁 实现分布式同步 (即只有一个线程会执行最新K线转存到数据库和redis中历史K线)

- 获取整个交易所所有种类的最新K线通过Pipeline获取

#### 压测
- 1000 / (4次 * 1.5ms) = 200 tps    400
- 200 * 10台 = 2000 tps  4000
- 

