- 解决的问题
    - 带环境安装软件
        - 操作系统设置环境变量等、各种依赖库和组件
        
- pk
    - 虚拟机
        - 对于底层系统来说，虚拟机就是一个普通文件
        - 可以在一种操作系统里面运行另一种操作系统
        - 资源占用多、冗余步骤多、启动慢
    - Linux 容器 (LXC)
        - 不是模拟一个完整的操作系统，而是对进程进行隔离
            - 或者说，在正常进程的外面套了一个保护层。对于容器里面的进程来说，它接触到的各种资源都是虚拟的，从而实现与底层系统的隔离
        - 容器是进程级别的，相比虚拟机有很多优势
            - 启动快，启动容器相当于启动本机的一个进程
            - 资源占用少，另外，多个容器可以共享资源，虚拟机都是独享资源
            - 体积小， 容器文件比虚拟机文件要小很多
            - 容器有点像轻量级的虚拟机，能够提供虚拟化的环境，但是成本开销小得多
    - Docker
        - Docker 属于 Linux 容器的一种封装，提供简单易用的容器使用接口。它是目前最流行的 Linux 容器解决方案
        - Docker 将应用程序与该程序的依赖，打包在一个文件里面；运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样
        - Docker 把应用程序及其依赖，打包在 image 文件里面；image 文件可以看作是容器的模板。Docker 根据 image 文件生成容器的实例
        


- Docker
    - Dockerfile文件 
        - 项目的根目录下 .dockerignore 排除不要打包进入 image 文件的文件目录
        - Dockerfile文本文件； 一个文本文件，用来配置 image
            - FROM 继承另一个 image 文件
    - image 文件
        - docker image build命令创建 image 文件
            - 默认的标签(版本) latest
    - 生成容器文件并运行容器
        - docker container run
            - 每运行一次，就会新建一个容器文件并运行
        - docker container start 用来启动已经生成、已经停止运行的容器文件
    - 终止容器运行
        - 关闭容器并不会删除容器文件
        - docker container kill
            - docker container kill命令终止容器运行，相当于向容器里面的主进程发出 SIGKILL 信号
        - docker container stop命令也是用来终止容器运行，相当于向容器里面的主进程发出 SIGTERM 信号，然后过一段时间再发出 SIGKILL 信号
        - 应用程序收到 SIGTERM 信号以后，可以自行进行收尾清理工作，但也可以不理会这个信号。如果收到 SIGKILL 信号，就会强行立即终止，那些正在进行中的操作会全部丢失
    - 删除容器文件
        - docker container rm
    - 发布 image 文件   
        - docker image push
    - 一些命令
        - CMD vs RUN
            - RUN命令在 image 文件的构建阶段执行，执行结果都会打包进入 image 文件；CMD命令则是在容器启动后执行。另外，一个 Dockerfile 可以包含多个RUN命令，但是只能有一个CMD命令
            - 指定了CMD命令以后，docker container run命令就不能附加命令了（比如前面的/bin/bash），否则它会覆盖CMD命令
        - docker container logs 命令用来查看 docker 容器的输出，即容器里面 Shell 的标准输出。如果docker run命令运行容器的时候，没有使用-it参数，就要用这个命令查看输出
        - docker container exec 命令用于进入一个正在运行的 docker 容器。如果docker run命令运行容器的时候，没有使用-it参数，就要用这个命令进入容器。一旦进入了容器，就可以在容器的 Shell 执行命令
        - VOLUME
            - dockerfile的 VOLUME 指令可以在镜像中创建挂载点，这样只要通过该镜像创建的容器都有了挂载点； VOLUME 指令创建的挂载点，无法指定主机上对应的目录，是自动生成的
            - docker本身提供了一种机制，可以将主机上的某个目录与容器的某个目录（称为挂载点、或者叫卷）关联起来，容器上的挂载点下的内容就是主机的这个目录下的内容，反过来也是
                - 容器是基于镜像创建的，最后的容器文件系统包括镜像的只读层+可写层，容器中的进程操作的数据持久化都是保存在容器的可写层上，解决一旦容器删除后，这些数据就没了
                - 容器共享卷（挂载点）
        - EXPOSE
            - EXPOSE 指令是声明容器运行时提供服务的端口，这只是一个声明，在容器运行时并不会因为这个声明应用就会开启这个端口的服务;
            - 并不会自动在宿主进行端口映射 需要运行容器时使用-p
            - -p，是映射宿主端口和容器端口，换句话说，就是将容器的对应端口服务公开给外界访问
        - ENTRYPOINT
            - 容器启动时运行的命令
        - -d:仍然表示后台执行
- Docker 微服务
    - Docker 使得软件可以拆分成若干个标准化容器，然后像搭积木一样组合起来
    - 站在 Docker 的角度，软件就是容器的组合
    
    - 微服务（microservices）的思想：软件把任务外包出去，让各种外部服务完成这些任务，软件本身只是底层服务的调度中心和组装层
    - 微服务很适合用 Docker 容器实现，每个容器承载一个服务
    
    - Docker Compose
        - 管理多个 Docker 容器组成一个应用
        - 定义一个 YAML 格式的配置文件docker-compose.yml，写好多个容器之间的调用关系
        - 只要一个命令，就能同时启动/关闭这些容器(docker-compose.yml所在的文件家里)
            - docker-compose up 、docker-compose stop、docker-compose rm(可以把这两个容器文件删除（容器必须已经停止运行）)
        - 通过 docker-compose 可以实现对多个微服务以及微服务高可用的编排，统一管理    