
- TCP
- 所谓的“连接”，其实是客户端和服务器的内存里保存的一份关于对方的信息，如ip地址、端口号等
- TCP提供了一种可靠(可以处理丢包、重复以及错误问题)、面向连接、字节流、传输层的服务，采用三次握手建立一个连接。采用4次挥手来关闭一个连接。
- 建立连接-三次握手
    - 过程
        1. (SYN)客户端发送一个SYN段，并指明客户端的初始序列号，即ISN(c).
        2. (SYN + ACK)服务端发送自己的SYN段作为应答，同样指明自己的ISN(s)。为了确认客户端的SYN，将ISN(c)+1作为ACK数值。这样，每发送一个SYN，序列号就会加1. 如果有丢失的情况，则会重传。
        3. (ACK)为了确认服务器端的SYN，客户端将ISN(s)+1作为返回的ACK数值。
    - 使双方都能明确自己和对方的收、发能力是正常的
    - 每次都是接收到数据包的一方可以得到一些结论
    - 其实3次握手的目的并不只是让通信双方都了解到一个连接正在建立，还在于利用数据包的选项来传输特殊的信息，交换初始序列号ISN，
    - 三次握手的一个重要功能是客户端和服务端交换ISN(Initial Sequence Number), 以便让对方知道接下来接收数据的时候如何按序列号组装数据
    
- 关闭连接-四次挥手
    - 过程
        1. 客户端发送一个FIN段，并包含一个希望接收者看到的自己当前的序列号K. 同时还包含一个ACK表示确认对方最近一次发过来的数据。 
        2. 服务端将K值加1作为ACK序号值，表明收到了上一个包。这时上层的应用程序会被告知另一端发起了关闭操作，通常这将引起应用程序发起自己的关闭操作。 
        3. 服务端发起自己的FIN段，ACK=K+1, Seq=L 
        4. 客户端确认。ACK=L+1
    - 注意，接收到FIN报文的一方只能回复一个ACK, 它是无法马上返回对方一个FIN报文段的，因为结束数据传输的“指令”是上层应用层给出的，上层应用可能数据并未发送完，我只是一个“搬运工”，我无法了解“上层的意志”

    1.当客户端没有待发送的数据时，它会向服务端发送 FIN 消息，发送消息后会进入 FIN_WAIT_1 状态；
    2.服务端接收到客户端的 FIN 消息后，会进入 CLOSE_WAIT 状态并向客户端发送 ACK 消息，客户端接收到 ACK 消息时会进入 FIN_WAIT_2 状态；
    3.当服务端没有待发送的数据时，服务端会向客户端发送 FIN 消息；
    4.客户端接收到 FIN 消息后，会进入 TIME_WAIT 状态并向服务端发送 ACK 消息，服务端收到后会进入 CLOSED 状态；
    5.客户端等待两个最大数据段生命周期（Maximum segment lifetime，MSL）2的时间后也会进入 CLOSED 状态
- 关闭连接客户端等待两个最大数据段生命周期
    - 数据段在网络中能够存活的最长时间，即 MSL
    - 2倍
        - 网络中可能存在来自发起方的数据段，当这些发起方的数据段被服务端处理后又会向客户端发送响应，所以一来一回需要等待 2 倍的时间
    - TIME_WAIT 仅在主动断开连接的一方出现，被动断开连接的一方会直接进入 CLOSED 状态，进入 TIME_WAIT 的客户端需要等待 2 MSL 才可以真正关闭连接
    - 客户端需要等待两个 MSL 不能直接进入 CLOSED 状态的原因
        - 防止延迟的数据段被其他使用相同源地址、源端口、目的地址以及目的端口的 TCP 连接收到
            - 因为数据段的网络传输时间不确定，所以可能会收到上一次 TCP 连接中未被收到的数据段
        - 保证 TCP 连接的远程被正确关闭，即等待被动关闭连接的一方收到 (其发送的)FIN 对应的 ACK 消息
            - 因为客户端发出的 ACK 可能还没有被服务端接收，服务端可能还处于 LAST_ACK 状态，所以仍然认为当前连接是合法的，客户端重新发送 SYN 消息请求握手时会收到服务端的 RST 消息，连接建立的过程就会被终止(RST表示复位，用来异常的关闭连接)
    - 客户端等待足够长的时间就会遇到以下两种情况
        - 服务端正常收到了 ACK 消息并关闭当前 TCP 连接；
        - 服务端没有收到 ACK 消息，重新发送 FIN 关闭连接并等待新的 ACK 消息
- 建立连接是三次握手，而关闭连接却是四次挥手
    - 3次握手是指发送了3个报文段，4次挥手是指发送了4个报文段。注意，SYN和FIN段都是会利用重传进行可靠传输的
    - 建立连接时服务端在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端，而关闭连接时，当收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方是否现在关闭发送数据通道，需要上层应用来决定，因此，己方ACK和FIN一般都会分开发送

- ACK
    - ACK是累积的，一个确认字节号N的ACK表示所有直到N的字节（不包括N）已经成功被接收了。这样的好处是如果一个ACK丢失，很可能后续的ACK就足以确认前面的报文段了
   
- 序列号
    - tcp对于丢包和乱序等问题的判断都是依赖于序列号大小比较的
    - 因为TCP使用IP来传输报文段，而IP不提供重复消除或者保证次序正确的功能
    - 作用是使得一个TCP接收端可丢弃重复的报文段，记录以杂乱次序到达的报文段
    - 另一方面，TCP是一个字节流协议，绝不会以杂乱的次序给上层程序发送数据。因此TCP接收端会被迫先保持大序列号的数据不交给应用程序，直到缺失的小序列号的报文段被填满
    - ISN： 三次握手的一个重要功能是客户端和服务端交换ISN(Initial Sequence Number), 以便让对方知道接下来接收数据的时候如何按序列号组装数据。
    - 序列号回绕
        - ISN是随机的，所以序列号容易就会超过2^31-1. 此时就出现了所谓的tcp序列号回绕（sequence wraparound）问题
        - 序列号发生回绕后，序列号变小，相减之后，把结果变成有符号数了，因此结果成了负数
    
- TCP头部
    - 源端口和目的端口在TCP层确定双方进程
    - 序列号表示的是报文段数据中的第一个字节号
    - ACK表示确认号(ACK位被启用的时候才有效): 该确认号的发送方期待接收的下一个序列号，即确认号等于最后被成功接收的数据字节序列号加1
        - 不消耗序列号，不使用重传进行可靠传输
    - SYN位 用于初如化一个连接的序列号
        - SYN报文段： 当新建一个连接时，从客户端发送到服务端的第一个报文段的SYN位被启用，这称为SYN报文段，这时序列号字段包含了在本次连接的这个方向上要使用的第一个序列号，即初始序列号ISN，之后发送的数据是ISN加1，因此SYN位字段会消耗一个序列号，这意味着使用重传进行可靠传输
            - 会消耗一个序列号
    - RST —— 重置连接（经常看到的reset by peer）就是此字段搞的鬼
    - FIN —— 该报文段的发送方已经结束向对方发送数据。
- syn flood攻击       
    - 当开放了一个TCP端口后，该端口就处于Listening状态，不停地监视发到该端口的Syn报文，一 旦接收到Client发来的Syn报文，就需要为该请求分配一个TCB，通常一个TCB至少需要280个字节，在某些操作系统中TCB甚至需要1300个字节，并返回一个SYN ACK命令，立即转为SYN-RECEIVED即半开连接状态
    - 如果恶意的向某个服务器端口发送大量的SYN包，则可以使服务器打开大量的半开连接，分配TCB（Transmission Control Block）, 从而消耗大量的服务器资源，同时也使得正常的连接请求无法被相应
    - 解决
        - 监视系统的半开连接和不活动连接，当达到一定阈值时拆除这些连接，从而释放系统资源，正常连接请求也被淹没在其中被这种方式误释放掉
        - 延缓TCB分配方法，当正常连接建立起来后再分配TCB，消耗服务器资源主要是因为当SYN数据报文一到达，系统立即分配TCB，从而占用了资源
            - Syn Cache
                - 系统在收到一个SYN报文时，在一个专用HASH表中保存这种半连接信息，直到收到正确的回应ACK报文再分配TCB。这个开销远小于TCB的开销。当然还需要保存序列号
            - Syn Cookie
                - Syn Cookie技术则完全不使用任何存储资源，这种方法比较巧妙，它使用一种特殊的算法生成Sequence Number，在收到对方 的ACK报文后，重新计算一遍，看其是否与对方回应报文中的（Sequence Number-1）相同，从而决定是否分配TCB资源。
        - SYN Proxy防火墙
            - 一种方式防火墙代服务器发出的SYN ACK包使用的序列号为c, 而真正的服务器回应的序列号为c', 这样，在每个数据报文经过防火墙的时候进行序列号的修改
            - 另一种方式是防火墙确定了连接的安全后，会发出一个safe reset命令，client会进行重新连接，这时出现的syn报文会直接放行。这样不需要修改序列号了。但是，client需要发起两次握手过程，因此建立连接的时间将会延长
- 连接队列
    - 从服务端来说，三次握手中，第一步server接受到client的syn后，把相关信息放到半连接队列中，同时回复syn+ack给client. 第三步当收到客户端的ack, 将连接加入到全连接队列。
    - 在外部请求到达时，被服务程序最终感知到前，连接可能处于
        1. SYN_RCVD状态
        2. ESTABLISHED状态，但还未被应用程序接受
    - 服务器端也会维护两种队列
        1. 半连接队列，对应处于SYN_RCVD半开连接状态的
            - 服务器已收到SYN包，该队列为每个客户端的SYN包开设一个条目，并向客户发出确认，正在等待客户的确认包
            - 当服务器收到客户的确认包时，删除该条目，服务器进入ESTABLISHED状态。
            - 服务端在接收到SYN包的时候，就已经创建了request_sock结构，存储在半连接队列中
            - 指数退避
                - 目前，Linux下默认会进行5次重发SYN-ACK包，重试的间隔时间从1s开始，下次的重试间隔时间是前一次的双倍，5次的重试时间间隔为1s, 2s, 4s, 8s, 16s, 总共31s, 称为指数退避，第5次发出后还要等32s才知道第5次也超时了，所以，总共需要 1s + 2s + 4s+ 8s+ 16s + 32s = 63s, TCP才会把断开这个连接。
        2. 全连接队列，对应处于ESTABLISHED状态但仍未被应用程序accept的
            - 当第三次握手时，当server接收到ACK包之后，会进入一个新的叫 accept 的队列
    - 如果这两个队列满了之后，就会出现各种丢包的情形。
        - 当外部连接请求到来时，TCP模块会首先查看max_syn_backlog，如果处于SYN_RCVD状态的连接数目超过这一阈值，进入的连接会被拒绝。根据tcp_abort_on_overflow字段来决定是直接丢弃，还是直接reset.
        - 一般，全连接队列比较小，会先满，此时半连接队列还没满。如果这时收到syn报文，则会进入半连接队列，没有问题。但是如果收到了三次握手中的第3步(ACK)，则会根据tcp_abort_on_overflow字段来决定是直接丢弃，还是直接reset
            - 此时各种情况怎么处理？ 
            - 但此时服务端可能因为全连接队列满了而无法将连接放入，会重新发送第2步的syn+ack, 如果这时有数据到来，服务器TCP模块会将数据存入队列中。一段时间后，client端没收到回复，超时，连接异常，client会主动关闭连接。

        - 半连接队列满了
            - SYN flood攻击
                - 由于，SYN超时需要63秒，那么就给攻击者一个攻击服务器的机会，攻击者在短时间内发送大量的SYN包给Server(俗称SYN flood攻击)，用于耗尽Server的SYN队列
                - linux提供了几个TCP参数：tcp_syncookies、tcp_synack_retries、tcp_max_syn_backlog、tcp_abort_on_overflow 来调整应对
            - tcp_max_syn_backlog 默认1000 半连接队列长度 超过则放弃当前连接
        - 全连接队列满了
            - 当accept队列满了之后，即使client继续向server发送ACK的包，也会不被响应
            - server通过tcp_abort_on_overflow来决定如何返回
                - 0表示直接丢弃该ACK，  
                    - 返回read timeout
                    - server过一段时间再次发送syn+ack给client（也就是重新走握手的第二步），如果client超时等待比较短，就很容易异常了。而客户端收到多个 SYN ACK 包，则会认为之前的 ACK 丢包了。于是促使客户端再次发送 ACK ，在 accept队列有空闲的时候最终完成连接。
                - 1表示发送RST通知client
                    - 返回connection reset by peer
        - tcp队列相关参数 cat /etc/sysctl.conf
    - 相关命令
        - netstat -s命令
        - ss命令
        
#### 粘包

- 粘包的原因
- netty解决方法

- tcp相关优化参数


#### 一台服务器可以建立多少个tcp连接

"TCP连接四元组是源IP地址、源端口、目的IP地址和目的端口。任意一个元素发生了改变，那么就代表的是一条完全不同的连接了。拿我的Nginx举例，它的端口是固定使用80。另外我的IP也是固定的，这样目的IP地址、目的端口都是固定的。剩下源IP地址、源端口是可变的。所以理论上我的Nginx上最多可以建立2的32次方（ip数）×2的16次方（port数）个连接。这是两百多万亿的一个大数字！！"

"进程每打开一个文件（linux下一切皆文件，包括socket），都会消耗一定的内存资源。如果有不怀好心的人启动一个进程来无限的创建和打开新的文件，会让服务器崩溃。所以linux系统出于安全角度的考虑，在多个位置都限制了可打开的文件描述符的数量，包括系统级、用户级、进程级。这三个限制的含义和修改方式如下："
系统级：当前系统可打开的最大数量，通过fs.file-max参数可修改
用户级：指定用户可打开的最大数量，修改/etc/security/limits.conf
进程级：单个进程可打开的最大数量，通过fs.nr_open参数可修改
- 每条tcp需要file、socket等内核对象，每条空tcp连接共消耗3.3kb左右

"接收缓存区大小是可以配置的，通过sysctl命令就可以查看。"
$ sysctl -a | grep rmem
net.ipv4.tcp_rmem = 4096 87380 8388608
net.core.rmem_default = 212992
net.core.rmem_max = 8388608
"其中在tcp_rmem"中的第一个值是为你们的TCP连接所需分配的最少字节数。该值默认是4K，最大的话8MB之多。也就是说你们有数据发送的时候我需要至少为对应的socket再分配4K内存，甚至可能更大。"


"TCP分配发送缓存区的大小受参数net.ipv4.tcp_wmem配置影响。"
$ sysctl -a | grep wmem
net.ipv4.tcp_wmem = 4096 65536 8388608
net.core.wmem_default = 212992
net.core.wmem_max = 8388608
"在net.ipv4.tcp_wmem"中的第一个值是发送缓存区的最小值，默认也是4K。当然了如果数据很大的话，该缓存区实际分配的也会比默认值大。"


活动连接数量
```
$ ss -n | grep ESTAB | wc -l  
1000024
```

2g内存 2*1024*1024/12 = 174,762.6666666 十几万连接 


二、查看TCP连接数

1)统计80端口连接数
netstat -nat|grep -i "80"|wc -l

2）统计httpd协议连接数
ps -ef|grep httpd|wc -l

3）、统计已连接上的，状态为“established
netstat -na|grep ESTABLISHED|wc -l