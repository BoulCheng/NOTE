
##### socket
- Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。
- 在设计模式中，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。
- 套接字(socket)通信可以分为流式套接字（TCP）和数据报套接字（UDP）

- 由于TCP的数据传输比较复杂，存在拆包和装包的可能



#### 粘包
- TCP 协议粘包问题是因为应用层协议开发者的错误设计导致的，他们忽略了 TCP 协议数据传输的核心机制 — 基于字节流，其本身不包含消息、数据包等概念，所有数据的传输都是流式的，需要应用层协议自己设计消息的边界，即消息帧（Message Framing）
- 粘包问题出现的核心原因
    - TCP 协议是基于字节流的传输层协议，其中不存在消息和数据包的概念；
    - 应用层协议没有使用基于长度或者基于终结符的消息边界，导致多个消息的粘连；
- TCP 协议是面向连接的、可靠的、基于字节流的传输层通信协议
- 应用层写入的数据包会被 TCP/IP 协议拆分发送
    - TCP 协议会分段传输过大的数据段（Segment）保证传输的性能
    - IP 协议会分片传输过大的数据包（Packet）避免物理设备的限制


#### https
- TLS的握手阶段是发生在TCP握手之后 TCP->TLS(Transport Layer Security) -> http
- HTTPS解决的问题
    - 信息加密传输：第三方无法窃听；
    - 校验机制：一旦被篡改，通信双方会立刻发现；
    - 身份证书：防止身份被冒充

- 对称加密
    - 加解密速度快，性能高
    - 给报文加密

- 非对称加密
    - server 也可以向 CA 申请证书，在证书中附上站点公钥，然后将证书传给 client，证书由站点管理者向 CA 申请，申请的时候会提交 DNS 主机名等信息，CA 会根据这些信息生成证书
    - 站点公开密钥
        - server发布公钥给其他client
    - 站点私钥
    - client把对称加密的密钥通过站点公开密钥加密 传送给 server ，server通过站点私钥解密，即协商好对称加密密钥
    
- CA 证书
    - server有CA 证书保存站点公钥
    - client有信任的证书保存着 CA公钥，用于验证来自server的CA证书合法性 从而拿到合法的站点公钥
- CA 私钥
    - 使用一些摘要算法（如 MD5）将证书明文（如证书序列号，DNS主机名，站点公开密钥等）生成摘要，然后再用第三方权威机构的CA 私钥对生成的摘要进行加密（签名）
    - 数字签名
    - 验证证书的真实性
- CA 公钥
    - 客户端有很多内置的被信任的证书
    - 客户端机器 内置 CA 证书中的公钥
    - 此公钥是存在于 CA 证书上，而此证书（也称 Root CA 证书）被操作系统信任，内置在操作系统上的，无需传输
    - 客户端除了通过验签的方式验证证书是否合法之外，还需要验证证书上的域名与自己的请求域名是否一致
    - 不要随便信任第三方的证书
    
### 一次完整的HTTP请求过程

- http如何解决粘包问题 udp是否有粘包
- http请求头有content-length字段。根据这个字段确定内容长度。如果没有这个字段，就是transfer-encoding:chunked。这表明内容是长度，内容，长度，内容，........0，空行
- 1.TCP协议是面向流的协议，UDP是面向消息的协议
  
  UDP段都是一条消息，应用程序必须以消息为单位提取数据，不能一次提取任意字节的数据
  
  
  
  2.UDP具有保护消息边界，在每个UDP包中就有了消息头（消息来源地址，端口等信息），这样对于接收端来说就容易进行区分处理了。传输协议把数据当作一条独立的消息在网上传输，接收端只能接收独立的消息。接收端一次只能接收发送端发出的一个数据包,如果一次接受数据的大小小于发送端一次发送的数据大小，就会丢失一部分数据，即使丢失，接受端也不会分两次去接收